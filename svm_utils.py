# -*- coding: utf-8 -*-
"""svm_utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/172y3xpWP16AE_rpf3dsd7mmuEihf4OBE
"""

#from google.colab.patches import cv2_imshow
import cv2
import numpy as np
from matplotlib import pyplot as plt
import random
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import classification_report

# all feat

def get_feat(img):
  ret,thresh = cv2.threshold(img,127,255,0)
  contours,hierarchy = cv2.findContours(thresh, 1, 2)
  #print(len(contours))
  #cv2_imshow(thresh)


  M_all = np.empty((29, 0))

  for cnt in contours:
    M = cv2.moments(cnt)
    M_vec = M.values()
    M_vec = np.array(list(M_vec)).flatten().reshape(-1,1)
    #print(M_vec.shape)

    area = cv2.contourArea(cnt)

    perimeter = cv2.arcLength(cnt,True)

    x,y,w,h = cv2.boundingRect(cnt)
    aspect_ratio = float(w)/h

    rect_area = w*h
    extent = float(area)/rect_area

    equi_diameter = np.sqrt(4*area/np.pi)

    feat_vec = np.array([area, perimeter, aspect_ratio, extent, equi_diameter]).reshape(-1,1)

    M_vec = np.vstack((M_vec, feat_vec))
    #print(M_vec.shape)
    M_all = np.hstack((M_all, M_vec))

  return M_all

def get_target(input_feats, target_class = 1):
  sh = input_feats.shape
  out = np.ones((sh[1],1))
  return out*target_class

def train_svm_3class (fimg_class1,fimg_class2,fimg_class3, cmplot=0, print_report=0, my_labels=['class1','class2','class3']):
  img2 = cv2.imread(fimg_class1, cv2.IMREAD_GRAYSCALE)
  feat1 = get_feat(img2)
  feat1 = np.delete(feat1, feat1.shape[1]-1, axis=1)

  img2 = cv2.imread(fimg_class2, cv2.IMREAD_GRAYSCALE)
  feat2 = get_feat(img2)
  feat2 = np.delete(feat2, feat2.shape[1]-1, axis=1)

  img2 = cv2.imread(fimg_class3, cv2.IMREAD_GRAYSCALE)
  feat3 = get_feat(img2)
  feat3 = np.delete(feat3, feat3.shape[1]-1, axis=1)

  t1 = get_target(feat1, 1)
  t2 = get_target(feat2, 2)
  t3 = get_target(feat3, 3)

  x_input = np.float32(np.concatenate((feat1,np.concatenate((feat2, feat3),axis =1)),axis =1).transpose())
  t_input = np.int64(np.concatenate((t1,np.concatenate((t2, t3)))))

  # Train the SVM
  mysvm = cv2.ml.SVM_create()
  mysvm.setType(cv2.ml.SVM_C_SVC)
  mysvm.setKernel(cv2.ml.SVM_LINEAR)
  mysvm.setTermCriteria((cv2.TERM_CRITERIA_MAX_ITER, 10000, 1e-6))
  mysvm.train(x_input, cv2.ml.ROW_SAMPLE, t_input)

  y_pred = mysvm.predict(x_input)[1]
  svm_acc = accuracy_score(t_input, y_pred) #y_true = t_input

  if (print_report==1):
    print(classification_report(t_input, y_pred, target_names=my_labels))
  else:
    print('SVM trained with '+str(svm_acc)+' accuracy.')  

  if (cmplot==1):
    CMdisp = ConfusionMatrixDisplay(confusion_matrix(t_input, y_pred), display_labels=my_labels)
    CMdisp.plot()


  return mysvm

def show_svm3_preds(svm,img_fname):
  img2 = cv2.imread(img_fname, cv2.IMREAD_GRAYSCALE)
  feat_test = get_feat(img2)
  #feat_test = np.delete(feat_test, feat_test.shape[1]-1, axis=1)
  #print(feat_test.shape)

  ret,thresh = cv2.threshold(img2,127,255,0)
  contours,hierarchy = cv2.findContours(thresh, 1, 2)
  #print(len(contours))

  contours,hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) 
  #mode: cv2.RETR_EXTERNAL / cv2.RETR_FLOODFILL
  # aproximtion: cv2.CHAIN_APPROX_NONE / cv2.CHAIN_APPROX_SIMPLE
  img3 = cv2.cvtColor(img2,cv2.COLOR_GRAY2RGB)

  for x in range(len(contours)):
      sampleMat = np.float32(feat_test[:,x].reshape(-1,1).transpose())
      response = svm.predict(sampleMat)[1]

      cnt = contours[x]

      if response == 1:
        cv2.drawContours(img3, [cnt], 0, (0,255,0), 3) # zielony = ryz
      elif response == 2:
        cv2.drawContours(img3, [cnt], 0, (255,0,0), 3) # niebieski = soczewica
      elif response == 3:
        cv2.drawContours(img3, [cnt], 0, (0,0,255), 3) # czerwony = fasola
      else:
        cv2.drawContours(img3, [cnt], 0, (255,255,255), 3)

  #cv2_imshow(img3)
  plt.figure(figsize=(10,10))
  plt.imshow(cv2.cvtColor(img3, cv2.COLOR_BGR2RGB))

